<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relaxing Breathing Exercise</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* --- Theme Variables --- */
        :root {
            --bg-color: #E8F0F2;
            --text-color: #555;
            --panel-bg: rgba(255, 255, 255, 0.95);
            --panel-shadow: -2px 0 10px rgba(0,0,0,0.15);
            --control-label-color: #333;
            --debug-bg: rgba(221, 221, 221, 0.8);
            --debug-text: #444;
            --menu-toggle-bg: rgba(165, 207, 240, 0.7);
            --menu-toggle-hover: rgba(165, 207, 240, 0.9);
            --menu-toggle-open-bg: rgba(217, 117, 113, 0.8);
            --menu-icon-color: white;
            --circle-gradient-edge: #FFFFFF;
            --slider-track: #ccc;
            --slider-thumb: #6cb86c;
            --button-bg: #6cb86c;
            --button-hover-bg: #5cae5c;
            --button-off-bg: #d97571;
            --button-off-hover-bg: #c9605c;
            --switch-checked-bg: #A5CFF0;
        }

        body.dark-mode {
            --bg-color: #2C3E50; /* Dark Blue-Gray */
            --text-color: #BDC3C7; /* Light Gray */
            --panel-bg: rgba(52, 73, 94, 0.97); /* Darker Blue-Gray */
            --panel-shadow: -2px 0 10px rgba(0,0,0,0.4);
            --control-label-color: #ECF0F1; /* Very Light Gray */
            --debug-bg: rgba(44, 62, 80, 0.8);
            --debug-text: #BDC3C7;
            --menu-toggle-bg: rgba(93, 109, 126, 0.7); /* Darker Gray */
            --menu-toggle-hover: rgba(93, 109, 126, 0.9);
            --menu-toggle-open-bg: rgba(231, 76, 60, 0.8); /* Darker Red */
            --menu-icon-color: #ECF0F1;
            --circle-gradient-edge: #34495E; /* Darker edge for gradient */
            --slider-track: #566573;
            --slider-thumb: #A5CFF0; /* Use light blue for thumb */
            --button-bg: #5cae5c; /* Slightly different green */
            --button-hover-bg: #4cae4c;
            --button-off-bg: #c9605c; /* Slightly different red */
            --button-off-hover-bg: #b9504c;
            --switch-checked-bg: #5dade2; /* Slightly different blue */
        }
        /* --- End Theme Variables --- */

        /* Basic styling for the page */
        body {
            display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; margin: 0; padding: 20px;
            background-color: var(--bg-color); font-family: sans-serif; box-sizing: border-box; color: var(--text-color); position: relative; overflow-x: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* --- Unique Menu System --- */
        #menu-toggle {
            position: fixed; top: 20px; right: 20px; width: 40px; height: 40px; background-color: var(--menu-toggle-bg); border-radius: 50%; cursor: pointer; z-index: 1001; display: flex; justify-content: center; align-items: center; box-shadow: 0 1px 3px rgba(0,0,0,0.1); transition: background-color 0.3s ease, transform 0.3s ease;
        }
        #menu-toggle:hover { background-color: var(--menu-toggle-hover); transform: scale(1.1); }
        #menu-toggle::before, #menu-toggle::after { content: ''; position: absolute; width: 18px; height: 3px; background-color: var(--menu-icon-color); border-radius: 1.5px; transition: transform 0.3s ease, background-color 0.3s ease; }
        #menu-toggle::after { transform: rotate(90deg); }
        body.menu-open #menu-toggle::before { transform: rotate(45deg); }
        body.menu-open #menu-toggle::after { transform: rotate(-45deg); }
        body.menu-open #menu-toggle { background-color: var(--menu-toggle-open-bg); }

        #menu-panel {
            position: fixed; top: 0; right: 0; width: 280px; max-width: 80%; height: 100%; background-color: var(--panel-bg); box-shadow: var(--panel-shadow); padding: 70px 20px 20px 20px; box-sizing: border-box; transform: translateX(100%); opacity: 0; visibility: hidden; transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.4s ease, visibility 0s linear 0.4s, background-color 0.3s ease; z-index: 1000; overflow-y: auto;
        }
        body.menu-open #menu-panel { transform: translateX(0); opacity: 1; visibility: visible; transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.4s ease, visibility 0s linear 0s, background-color 0.3s ease; }

        /* Controls inside the menu panel */
        .controls { display: flex; flex-direction: column; align-items: center; gap: 20px; /* Slightly reduced gap */ width: 100%; }
        .control-group { display: flex; flex-direction: column; align-items: center; gap: 8px; width: 100%; }
        .controls label { font-size: 1rem; color: var(--control-label-color); font-weight: 500; transition: color 0.3s ease; }
        .controls select { padding: 10px 15px; border: 1px solid #ccc; border-radius: 5px; background-color: white; color: #333; font-size: 1rem; cursor: pointer; width: 100%; text-align: center; box-sizing: border-box; }
        .controls select:focus { outline: none; border-color: #a5cff0; box-shadow: 0 0 5px rgba(165, 207, 240, 0.6); }

        /* Buttons */
        .control-button { padding: 12px 25px; font-size: 1rem; border: none; border-radius: 5px; cursor: pointer; background-color: var(--button-bg); color: white; transition: background-color 0.2s ease; width: 100%; box-sizing: border-box; }
        .control-button:hover { background-color: var(--button-hover-bg); }
        .control-button.button-off { background-color: var(--button-off-bg); }
        .control-button.button-off:hover { background-color: var(--button-off-hover-bg); }

        /* Volume slider */
        #volume-slider { cursor: pointer; width: 100%; -webkit-appearance: none; appearance: none; height: 8px; background: var(--slider-track); border-radius: 4px; outline: none; transition: background-color 0.3s ease; }
        #volume-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: var(--slider-thumb); border-radius: 50%; cursor: pointer; transition: background-color 0.3s ease; }
        #volume-slider::-moz-range-thumb { width: 18px; height: 18px; background: var(--slider-thumb); border-radius: 50%; cursor: pointer; border: none; transition: background-color 0.3s ease; }

        /* Toggle Switches (Dark Mode & Vibration) */
        .toggle-switch-group { display: flex; align-items: center; justify-content: space-between; width: 100%; margin-top: 5px; /* Reduced margin */ }
        .toggle-switch-group label { margin-right: 10px; }
        .switch { position: relative; display: inline-block; width: 50px; height: 26px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 26px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--switch-checked-bg); } /* Use variable */
        input:checked + .slider:before { transform: translateX(24px); }
        /* --- End Menu System --- */


        /* Styling for the circle element */
        .animated-circle { width: 150px; height: 150px; max-width: 50vw; max-height: 50vw; aspect-ratio: 1 / 1; margin-bottom: 25px; margin-top: 50px; --center-color: #A881B4; background: radial-gradient(circle, var(--center-color), var(--circle-gradient-edge)); border-radius: 50%; position: relative; display: flex; justify-content: center; align-items: center; transition: transform 0.2s linear, opacity 0.2s linear; }
        #breath-text { color: white; font-size: 1.2rem; font-weight: bold; text-align: center; user-select: none; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6); }
        #calm-phrase { margin-top: 15px; margin-bottom: 30px; min-height: 2.5em; font-size: 1.1rem; color: var(--text-color); text-align: center; font-style: italic; opacity: 0; transition: opacity 0.8s ease-in-out, color 0.3s ease; }
        #calm-phrase.visible { opacity: 1; }
        #debug-info { margin-top: auto; padding: 8px 12px; background-color: var(--debug-bg); border-radius: 5px; font-family: monospace; font-size: 0.85rem; color: var(--debug-text); text-align: center; transition: background-color 0.3s ease, color 0.3s ease; }
    </style>
</head>
<body>
    <div id="menu-toggle" title="Open Settings"></div>

    <div id="menu-panel">
        <div class="controls">
            <div class="control-group">
                <label for="technique-select">Breathing Technique:</label>
                <select id="technique-select"> </select>
            </div>
            <div class="control-group">
                 <label for="volume-slider">Sound Volume:</label>
                 <input type="range" id="volume-slider" min="-40" max="0" value="-25" step="1">
            </div>
             <button id="sound-toggle-button" class="control-button button-off">Start Sound</button> <div class="toggle-switch-group control-group">
                 <label for="vibration-switch">Vibration:</label>
                 <label class="switch">
                     <input type="checkbox" id="vibration-switch">
                     <span class="slider"></span>
                 </label>
             </div>
             <div class="toggle-switch-group control-group">
                 <label for="dark-mode-switch">Dark Mode:</label>
                 <label class="switch">
                     <input type="checkbox" id="dark-mode-switch">
                     <span class="slider"></span>
                 </label>
             </div>
             </div>
    </div>

    <div class="animated-circle">
        <span id="breath-text">Starting...</span>
    </div>
    <div id="calm-phrase"></div>
    <div id="debug-info">Select a technique</div>

    <script>
        // --- Configuration ---
        const techniques = { /* ... (no changes) ... */
            'default': { name: 'Default (4-7-8)', inhale: 4, hold: 7, exhale: 8, colorInhale: '#A5CFF0', colorHold: '#F0C8A5', colorExhale: '#A881B4' },
            'box': { name: 'Box Breathing (4-4-4)', inhale: 4, hold: 4, exhale: 4, colorInhale: '#A5CFF0', colorHold: '#F0C8A5', colorExhale: '#A881B4' },
            'relax': { name: 'Relaxing Breath (4-2-6)', inhale: 4, hold: 2, exhale: 6, colorInhale: '#A5CFF0', colorHold: '#F0C8A5', colorExhale: '#A881B4' }
        };
        const minScale = 0.4; const maxScale = 1.0; const pulseScale = 1.02; const pulseFrequency = 1.0;
        const noiseType = 'brown'; const filterFreqBase = 120; const filterFreqInhale = 1200; const filterFreqHold = 1200; const filterQ = 4;
        let currentVolume = -25;
        const calmingPhrases = ["Be present...", "Let go...", "Breathe...", "Peace...", "Safe & calm...", "Release...", "Focus...", "Relax...", "Stillness...", "Softness..."];
        let phraseIndex = 0; let showNewPhrase = true;

        // Vibration Patterns (ms duration)
        const vibrateInhale = [100];
        const vibrateHold = [150]; // Slightly longer
        const vibrateExhale = [80, 70, 80]; // Double pulse

        // --- Get DOM Elements ---
        const animatedCircle = document.querySelector('.animated-circle');
        const breathText = document.getElementById('breath-text');
        const debugInfo = document.getElementById('debug-info');
        const techniqueSelect = document.getElementById('technique-select');
        const soundToggleButton = document.getElementById('sound-toggle-button');
        const volumeSlider = document.getElementById('volume-slider');
        const calmPhraseElement = document.getElementById('calm-phrase');
        const menuToggle = document.getElementById('menu-toggle');
        const menuPanel = document.getElementById('menu-panel');
        const bodyElement = document.body;
        const darkModeSwitch = document.getElementById('dark-mode-switch');
        const vibrationSwitch = document.getElementById('vibration-switch'); // Vibration switch

        // --- State Variables ---
        let currentTechniqueKey = 'default'; let currentTechnique = techniques[currentTechniqueKey];
        let startTime = performance.now(); let animationFrameId = null; let soundEnabled = false; let toneStarted = false; let synth = null;
        let vibrationEnabled = false; // Vibration state
        let previousPhase = ''; // Track phase changes for vibration trigger
        const vibrationApiSupported = 'vibrate' in navigator; // Check Vibration API support

        // --- Populate Select Options ---
        function populateOptions() { /* ... (no changes) ... */
             techniqueSelect.innerHTML = ''; for (const key in techniques) { const option = document.createElement('option'); option.value = key; option.textContent = techniques[key].name; techniqueSelect.appendChild(option); } techniqueSelect.value = currentTechniqueKey;
         }

        // --- Initialize Sound (Noise Synth) ---
        function initializeSound() { /* ... (no changes) ... */
             if (!synth) { synth = new Tone.NoiseSynth({ noise: { type: noiseType }, envelope: { attack: 0.6, decay: 0.1, sustain: 1.0, release: 1.0 }, filterEnvelope: { baseFrequency: filterFreqBase, octaves: 0, attack: 0.02, release: 0.2, filter: { Q: filterQ } }, volume: currentVolume }).toDestination(); console.log("NoiseSynth created with Q =", filterQ); }
         }

        // --- Linear Interpolation (Lerp) Function ---
        function lerp(start, end, amount) { /* ... (no changes) ... */ const clampedAmount = Math.max(0, Math.min(1, amount)); return start + (end - start) * clampedAmount; }

         // --- Color Interpolation Helper ---
        function lerpColor(hexColor1, hexColor2, amount) { /* ... (no changes) ... */ const color1 = hexToRgb(hexColor1); const color2 = hexToRgb(hexColor2); if (!color1 || !color2) return hexColor1; const r = Math.round(lerp(color1.r, color2.r, amount)); const g = Math.round(lerp(color1.g, color2.g, amount)); const b = Math.round(lerp(color1.b, color2.b, amount)); return rgbToHex(r, g, b); }
        function hexToRgb(hex) { /* ... (no changes) ... */ const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null; }
        function componentToHex(c) { /* ... (no changes) ... */ const hex = c.toString(16); return hex.length == 1 ? "0" + hex : hex; }
        function rgbToHex(r, g, b) { /* ... (no changes) ... */ return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b); }

        // --- Trigger Vibration ---
        function triggerVibration(pattern) {
            if (vibrationEnabled && vibrationApiSupported) {
                try {
                    navigator.vibrate(pattern);
                    console.log("Vibrating:", pattern);
                } catch (e) {
                    console.error("Vibration failed:", e);
                    // Optionally disable vibration toggle if it fails consistently
                }
            }
        }

        // --- Animation Loop ---
        function animate(currentTime) {
            const inhaleDuration = currentTechnique.inhale * 1000; const holdDuration = currentTechnique.hold * 1000; const exhaleDuration = currentTechnique.exhale * 1000; const totalDuration = inhaleDuration + holdDuration + exhaleDuration; const elapsedTime = (currentTime - startTime) % totalDuration; let phase = '', phaseProgress = 0, scale = minScale, opacity = 0.8, text = '', centerColor = currentTechnique.colorExhale, targetFilterFreq = filterFreqBase;

            // Determine current phase and progress
            if (elapsedTime < inhaleDuration) {
                phase = 'Inhale'; phaseProgress = elapsedTime / inhaleDuration; scale = lerp(minScale, maxScale, phaseProgress); opacity = lerp(0.8, 1.0, phaseProgress); text = 'Inhale'; centerColor = lerpColor(currentTechnique.colorExhale, currentTechnique.colorInhale, phaseProgress); targetFilterFreq = lerp(filterFreqBase, filterFreqInhale, phaseProgress);
                if (showNewPhrase) { calmPhraseElement.classList.remove('visible'); setTimeout(() => { phraseIndex = (phraseIndex + 1) % calmingPhrases.length; calmPhraseElement.textContent = calmingPhrases[phraseIndex]; calmPhraseElement.classList.add('visible'); }, 400); showNewPhrase = false; }
            } else if (elapsedTime < inhaleDuration + holdDuration) {
                phase = 'Hold'; const timeInHold = elapsedTime - inhaleDuration; phaseProgress = timeInHold / holdDuration; const pulseProgress = Math.sin(timeInHold / 1000 * pulseFrequency * Math.PI * 2) * 0.5 + 0.5; scale = lerp(maxScale, pulseScale, pulseProgress); opacity = 1.0; text = 'Hold'; centerColor = lerpColor(currentTechnique.colorInhale, currentTechnique.colorHold, phaseProgress); targetFilterFreq = filterFreqHold; showNewPhrase = false;
            } else {
                phase = 'Exhale'; const timeInExhale = elapsedTime - (inhaleDuration + holdDuration); phaseProgress = timeInExhale / exhaleDuration; scale = lerp(maxScale, minScale, phaseProgress); opacity = lerp(1.0, 0.8, phaseProgress); text = 'Exhale'; centerColor = lerpColor(currentTechnique.colorHold, currentTechnique.colorExhale, phaseProgress); targetFilterFreq = lerp(filterFreqHold, filterFreqBase, phaseProgress);
                if (phaseProgress > 0.9) { showNewPhrase = true; }
            }

            // --- Trigger Vibration on Phase Change ---
            if (phase !== previousPhase) {
                switch (phase) {
                    case 'Inhale': triggerVibration(vibrateInhale); break;
                    case 'Hold': triggerVibration(vibrateHold); break;
                    case 'Exhale': triggerVibration(vibrateExhale); break;
                }
                previousPhase = phase; // Update after checking
            }

            // Apply visual styles
            animatedCircle.style.transform = `scale(${scale})`; animatedCircle.style.opacity = opacity; animatedCircle.style.setProperty('--center-color', centerColor); breathText.textContent = text;
            // Sound Logic
            if (soundEnabled && synth && synth.state === 'started') { if (synth.filterEnvelope && synth.filterEnvelope.baseFrequency) { synth.filterEnvelope.baseFrequency.rampTo(targetFilterFreq, 0.3); } else { console.warn("Synth filterEnvelope or baseFrequency not available for ramping."); } }
            // Debug Info
            const cyclePercent = (elapsedTime / totalDuration) * 100; debugInfo.textContent = `Stage: ${phase} | Cycle: ${cyclePercent.toFixed(1)}%`;
            // Loop
            animationFrameId = requestAnimationFrame(animate);
        }

        // --- Menu Toggle Logic ---
        menuToggle.addEventListener('click', () => { /* ... (no changes) ... */ bodyElement.classList.toggle('menu-open'); });

        // --- Close Menu if Clicking Outside ---
        document.addEventListener('click', (event) => { /* ... (no changes) ... */ if (bodyElement.classList.contains('menu-open') && !menuPanel.contains(event.target) && !menuToggle.contains(event.target)) { bodyElement.classList.remove('menu-open'); } });

        // --- Event Listener for Select Change ---
        techniqueSelect.addEventListener('change', (event) => { /* ... (no changes) ... */ if (animationFrameId) cancelAnimationFrame(animationFrameId); if (soundEnabled && synth && synth.state === 'started') { synth.triggerRelease(Tone.now()); console.log("Technique Changed - Triggering Release"); soundEnabled = false; soundToggleButton.textContent = 'Start Sound'; soundToggleButton.classList.add('button-off'); } currentTechniqueKey = event.target.value; currentTechnique = techniques[currentTechniqueKey]; startTime = performance.now(); showNewPhrase = true; calmPhraseElement.classList.remove('visible'); calmPhraseElement.textContent = ''; bodyElement.classList.remove('menu-open'); previousPhase = ''; animationFrameId = requestAnimationFrame(animate); }); // Reset previousPhase

         // --- Event Listener for Sound Toggle ---
        soundToggleButton.addEventListener('click', async () => { /* ... (no changes) ... */ if (!toneStarted) { try { await Tone.start(); initializeSound(); toneStarted = true; console.log("AudioContext started."); } catch (e) { console.error("Tone.start() failed:", e); soundToggleButton.textContent = 'Sound Error'; soundToggleButton.disabled = true; return; } } if (!synth) { console.error("Synth not initialized."); if (toneStarted) initializeSound(); if (!synth) return; } if (!soundEnabled) { if (synth.state !== 'started') { synth.triggerAttack(Tone.now()); console.log("Sound Enabled - Triggering Attack"); soundEnabled = true; soundToggleButton.textContent = 'Stop Sound'; soundToggleButton.classList.remove('button-off'); } else { console.log("Sound already started?"); soundEnabled = true; soundToggleButton.textContent = 'Stop Sound'; soundToggleButton.classList.remove('button-off');} } else { if (synth.state === 'started') { synth.triggerRelease(Tone.now() + 0.1); console.log("Sound Disabled - Triggering Release"); soundEnabled = false; soundToggleButton.textContent = 'Start Sound'; soundToggleButton.classList.add('button-off'); } else { console.log("Sound already stopped?"); soundEnabled = false; soundToggleButton.textContent = 'Start Sound'; soundToggleButton.classList.add('button-off');} } });

        // --- Event Listener for Volume Slider ---
        volumeSlider.addEventListener('input', (event) => { /* ... (no changes) ... */ currentVolume = parseFloat(event.target.value); if (synth) { synth.volume.rampTo(currentVolume, 0.1); } console.log("Volume set to:", currentVolume); });

        // --- Dark Mode Logic ---
        function applyTheme(theme) { /* ... (no changes) ... */ if (theme === 'dark') { bodyElement.classList.add('dark-mode'); darkModeSwitch.checked = true; } else { bodyElement.classList.remove('dark-mode'); darkModeSwitch.checked = false; } }
        darkModeSwitch.addEventListener('change', () => { /* ... (no changes) ... */ const selectedTheme = darkModeSwitch.checked ? 'dark' : 'light'; localStorage.setItem('theme', selectedTheme); applyTheme(selectedTheme); });

        // --- Vibration Logic ---
        function applyVibrationSetting(enabled) {
            vibrationEnabled = enabled;
            vibrationSwitch.checked = enabled;
            // If disabling vibration, cancel any ongoing vibration immediately
            if (!enabled && vibrationApiSupported) {
                navigator.vibrate(0);
            }
            console.log("Vibration Enabled:", vibrationEnabled);
        }

        vibrationSwitch.addEventListener('change', () => {
            const isEnabled = vibrationSwitch.checked;
            localStorage.setItem('vibrationEnabled', isEnabled); // Save preference
            applyVibrationSetting(isEnabled);
            // Optional: Trigger a short confirmation vibration when enabled
            if (isEnabled) {
                triggerVibration([50]);
            }
        });

        // Disable vibration toggle if API not supported
        if (!vibrationApiSupported) {
            const vibrationToggleGroup = vibrationSwitch.closest('.toggle-switch-group');
            if (vibrationToggleGroup) {
                vibrationToggleGroup.style.opacity = '0.5';
                vibrationToggleGroup.style.pointerEvents = 'none';
                // Add a title to explain why it's disabled
                 const label = vibrationToggleGroup.querySelector('label');
                 if(label) label.title = "Vibration not supported on this device/browser.";
            }
            console.warn("Vibration API not supported.");
        }


        // --- Initialization ---
        populateOptions();
        volumeSlider.value = currentVolume;
        // Apply saved theme
        const savedTheme = localStorage.getItem('theme') || 'light';
        applyTheme(savedTheme);
        // Apply saved vibration setting
        const savedVibration = localStorage.getItem('vibrationEnabled') === 'true'; // Convert string to boolean
        if (vibrationApiSupported) { // Only apply if supported
             applyVibrationSetting(savedVibration);
        } else {
             applyVibrationSetting(false); // Ensure it's off if not supported
        }
        // Initialize animation loop
        startTime = performance.now();
        animationFrameId = requestAnimationFrame(animate);

    </script>
</body>
</html>
